"use strict";

var _assign = require("babel-runtime/core-js/object/assign");

var _assign2 = _interopRequireDefault(_assign);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require("babel-runtime/helpers/get");

var _get3 = _interopRequireDefault(_get2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

var _classnames = require("classnames");

var _classnames2 = _interopRequireDefault(_classnames);

var _reactGeminiScrollbar = require("react-gemini-scrollbar");

var _reactGeminiScrollbar2 = _interopRequireDefault(_reactGeminiScrollbar);

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactTransitionGroup = require("react-transition-group");

var _reactDom = require("react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _BindMixin = require("../Mixin/BindMixin");

var _BindMixin2 = _interopRequireDefault(_BindMixin);

var _DOMUtil = require("../Util/DOMUtil");

var _DOMUtil2 = _interopRequireDefault(_DOMUtil);

var _Keycodes = require("../constants/Keycodes");

var _Keycodes2 = _interopRequireDefault(_Keycodes);

var _Portal = require("../Portal/Portal.js");

var _Portal2 = _interopRequireDefault(_Portal);

var _Util = require("../Util/Util");

var _Util2 = _interopRequireDefault(_Util);

var _DropdownListTrigger = require("./DropdownListTrigger");

var _DropdownListTrigger2 = _interopRequireDefault(_DropdownListTrigger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Dropdown = function (_Util$mixin) {
  (0, _inherits3.default)(Dropdown, _Util$mixin);
  (0, _createClass3.default)(Dropdown, [{
    key: "methodsToBind",
    get: function get() {
      return ["closeDropdown", "handleMenuToggle", "handleExternalClick", "handleKeyDown", "handleMenuRender", "handleWrapperBlur"];
    }
  }]);

  function Dropdown() {
    (0, _classCallCheck3.default)(this, Dropdown);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Dropdown.__proto__ || (0, _getPrototypeOf2.default)(Dropdown)).call(this));

    _this.container = null;
    _this.state = {
      maxDropdownHeight: null,
      menuDirection: "down",
      menuHeight: null,
      menuPositionStyle: null,
      isOpen: false,
      renderHidden: false,
      selectedID: null
    };
    _this.dropdownMenuRef = _react2.default.createRef();
    _this.dropdownWrapperRef = _react2.default.createRef();
    return _this;
  }

  (0, _createClass3.default)(Dropdown, [{
    key: "componentWillMount",
    value: function componentWillMount() {
      (0, _get3.default)(Dropdown.prototype.__proto__ || (0, _getPrototypeOf2.default)(Dropdown.prototype), "componentWillMount", this).apply(this, arguments);

      var props = this.props;
      if (!props.persistentID) {
        this.setState({ selectedID: props.initialID });
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.container = this.getScrollContainer();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      if (this.state.isOpen) {
        global.addEventListener("resize", this.closeDropdown);
      } else {
        global.removeEventListener("resize", this.closeDropdown);
      }
    }
  }, {
    key: "componentWillUpdate",
    value: function componentWillUpdate(nextProps, nextState) {
      // If the open state changed, add or remove listener as needed.
      if (nextState.isOpen !== this.state.isOpen) {
        if (nextState.isOpen) {
          this.addKeydownListener();
          this.addScrollListener();
        } else {
          this.removeKeydownListener();
          this.removeScrollListener();
        }
      }
    }
  }, {
    key: "handleExternalClick",
    value: function handleExternalClick() {
      this.closeDropdown();
    }
  }, {
    key: "handleKeyDown",
    value: function handleKeyDown(event) {
      if (event.keyCode === _Keycodes2.default.esc) {
        this.closeDropdown();
      }
    }
  }, {
    key: "handleItemClick",
    value: function handleItemClick(item) {
      var props = this.props;
      props.onItemSelection(item);

      var newState = { isOpen: false };
      // Only set the selectedID if persistentID is not set
      if (!props.persistentID) {
        newState.selectedID = item.id;
      }

      this.setState(newState);
      this.removeBlurTimeout();
    }
  }, {
    key: "handleWrapperBlur",
    value: function handleWrapperBlur() {
      var _this2 = this;

      this.removeBlurTimeout();

      this.currentBlurTimeout = setTimeout(function () {
        _this2.closeDropdown();
      }, 150);

      // We need to remove focus from the button to avoid this event firing again
      // when we open the dropdown
      global.focus();
    }
  }, {
    key: "handleMenuToggle",
    value: function handleMenuToggle(e) {
      e.stopPropagation();

      if (this.state.isOpen) {
        this.closeDropdown();
      } else {
        this.openDropdown();
      }

      this.removeBlurTimeout();
    }
  }, {
    key: "handleMenuRender",
    value: function handleMenuRender() {
      // If the menu is hidden while rendering, then we need to calculate its
      // optimal location and then un-hide it.
      if (this.state.renderHidden) {
        this.determineOptimalMenuLocation();
      }
    }
  }, {
    key: "addKeydownListener",
    value: function addKeydownListener() {
      global.document.body.addEventListener("keydown", this.handleKeyDown);
    }
  }, {
    key: "addScrollListener",
    value: function addScrollListener() {
      if (this.container && this.container.current) {
        this.container.current.addEventListener("scroll", this.closeDropdown);
      }
    }
  }, {
    key: "removeKeydownListener",
    value: function removeKeydownListener() {
      global.document.body.removeEventListener("keydown", this.handleKeyDown);
    }
  }, {
    key: "removeScrollListener",
    value: function removeScrollListener() {
      if (this.container && this.container.current) {
        this.container.current.removeEventListener("scroll", this.closeDropdown);
      }
    }
  }, {
    key: "removeBlurTimeout",
    value: function removeBlurTimeout() {
      if (this.currentBlurTimeout) {
        global.clearTimeout(this.currentBlurTimeout);
      }
    }
  }, {
    key: "determineOptimalMenuLocation",
    value: function determineOptimalMenuLocation() {
      var height = null;
      var menuDirection = this.state.menuDirection;
      var menuPositionStyle = {};
      var spaceAroundDropdownButton = _DOMUtil2.default.getNodeClearance(this.dropdownWrapperRef.current);
      var dropdownChildHeight = this.dropdownMenuRef && this.dropdownMenuRef.current ? this.dropdownMenuRef.current.firstChild.clientHeight : 0;
      var menuHeight = this.state.menuHeight || dropdownChildHeight;
      var isMenuTallerThanBottom = menuHeight > spaceAroundDropdownButton.bottom;
      var isMenuTallerThanTop = menuHeight > spaceAroundDropdownButton.top;
      var isMenuShorterThanTop = !isMenuTallerThanTop;
      var isTopTallerThanBottom = spaceAroundDropdownButton.top > spaceAroundDropdownButton.bottom;
      // If the menu height is larger than the space available on the bottom and
      // less than the space available on top, then render it up. If the height
      // of the menu exceeds the space below and above, but there is more space
      // above than below, render it up. Otherwise, render down.
      if (isMenuTallerThanBottom && isMenuShorterThanTop || isMenuTallerThanBottom && isMenuTallerThanTop && isTopTallerThanBottom) {
        menuDirection = "up";
        menuPositionStyle.bottom = spaceAroundDropdownButton.bottom + spaceAroundDropdownButton.boundingRect.height;
        menuPositionStyle.top = "auto";
        height = spaceAroundDropdownButton.top;
      } else {
        menuDirection = "down";
        menuPositionStyle.bottom = "auto";
        menuPositionStyle.top = spaceAroundDropdownButton.top + spaceAroundDropdownButton.boundingRect.height;
        height = spaceAroundDropdownButton.bottom;
      }

      if (this.props.matchButtonWidth) {
        menuPositionStyle.left = spaceAroundDropdownButton.left;
        menuPositionStyle.right = spaceAroundDropdownButton.right;
      } else if (this.props.anchorRight) {
        menuPositionStyle.left = "auto";
        menuPositionStyle.right = spaceAroundDropdownButton.right;
      } else {
        menuPositionStyle.left = spaceAroundDropdownButton.left;
        menuPositionStyle.right = "auto";
      }

      // We assume that 125 pixels is the smallest height we should render.
      if (height < 125) {
        height = 125;
      }

      this.setState({
        menuDirection: menuDirection,
        maxDropdownHeight: height,
        menuHeight: menuHeight,
        menuPositionStyle: menuPositionStyle,
        renderHidden: false
      });
    }
  }, {
    key: "openDropdown",
    value: function openDropdown() {
      var state = (0, _assign2.default)({}, this.state);

      state.isOpen = true;
      state.renderHidden = true;

      // If we don't already know the menu height, we need to set the menu
      // position to a default state to trigger its recalculation on the next
      // render.
      if (this.state.menuHeight == null && this.dropdownWrapperRef && this.dropdownWrapperRef.current) {
        var buttonPosition = this.dropdownWrapperRef.current.getBoundingClientRect();

        state.menuDirection = "down";
        state.menuPositionStyle = {
          top: buttonPosition.top + buttonPosition.height,
          left: buttonPosition.left
        };
      }

      this.setState(state);
    }
  }, {
    key: "closeDropdown",
    value: function closeDropdown() {
      if (this.state.isOpen) {
        this.setState({ isOpen: false, renderHidden: false });
      }
    }
  }, {
    key: "getMenuItems",
    value: function getMenuItems(items) {
      var _this3 = this;

      var selectedID = this.getSelectedID();

      return items.map(function (item) {
        var classSet = (0, _classnames2.default)({
          "is-selectable": item.selectable !== false,
          "is-selected": item.id === selectedID
        }, item.className, _this3.props.dropdownMenuListItemClassName);

        var handleUserClick = null;

        if (item.selectable !== false) {
          handleUserClick = _this3.handleItemClick.bind(_this3, item);
        }

        return _react2.default.createElement(
          "li",
          { className: classSet, key: item.id, onClick: handleUserClick },
          item.html
        );
      });
    }
  }, {
    key: "getScrollContainer",
    value: function getScrollContainer() {
      var _props = this.props,
          scrollContainer = _props.scrollContainer,
          scrollContainerParentSelector = _props.scrollContainerParentSelector;


      if (typeof scrollContainer === "string") {
        // Find the closest scrolling element by the specified selector.
        scrollContainer = _DOMUtil2.default.closest(_reactDom2.default.findDOMNode(this), scrollContainer) || window;

        var _scrollContainer = scrollContainer,
            parentElement = _scrollContainer.parentElement;

        // If the user specified scrollContainerParentSelector, we check to see
        // if the parent scrolling element matches the specified parent selector.

        if (scrollContainer !== window && scrollContainerParentSelector != null && parentElement != null && parentElement[_DOMUtil2.default.matchesFn](scrollContainerParentSelector)) {
          scrollContainer = parentElement;
        }
      }

      return scrollContainer;
    }
  }, {
    key: "getSelectedID",
    value: function getSelectedID() {
      return this.props.persistentID || this.state.selectedID;
    }
  }, {
    key: "getSelectedItem",
    value: function getSelectedItem() {
      var _this4 = this;

      return this.props.items.find(function (item) {
        return item.id && item.id === _this4.getSelectedID();
      });
    }
  }, {
    key: "render",
    value: function render() {
      // Set a key based on the menu height so that React knows to keep the
      // the DOM element around while we are measuring it.
      var props = this.props,
          state = this.state;

      var dropdownMenu = _react2.default.createElement("div", { key: "placeholder-element" });
      var dropdownMenuClassSet = (0, _classnames2.default)(state.menuDirection, props.dropdownMenuClassName);
      var items = props.items,
          trigger = props.trigger;

      var transitionName = props.transitionName + "-" + state.menuDirection;
      var wrapperClassSet = (0, _classnames2.default)(state.menuDirection, props.wrapperClassName, {
        open: state.isOpen
      });

      if (state.isOpen) {
        var dropdownMenuItems = _react2.default.createElement(
          "ul",
          { className: "dropdown-menu-items" },
          this.getMenuItems(items)
        );

        // Render with Gemini scrollbar if the dropdown's height should be
        // constrainted.
        if (state.menuHeight >= state.maxDropdownHeight) {
          var height = "auto";

          // Remove 30 pixels from the dropdown height to account for offset
          // positioning from the dropdown button.
          if (state.maxDropdownHeight > 30) {
            height = state.maxDropdownHeight - 30;
          }

          var dropdownMenuStyle = { height: height };

          if (props.useGemini && height !== "auto") {
            dropdownMenuItems = _react2.default.createElement(
              _reactGeminiScrollbar2.default,
              {
                autoshow: true,
                className: "container-scrollable",
                style: dropdownMenuStyle
              },
              dropdownMenuItems
            );
          } else {
            dropdownMenuItems = _react2.default.createElement(
              "div",
              { className: "container-scrollable", style: dropdownMenuStyle },
              dropdownMenuItems
            );
          }
        }

        dropdownMenu = _react2.default.createElement(
          "span",
          {
            key: "dropdown-menu-key",
            className: dropdownMenuClassSet,
            role: "menu",
            ref: this.dropdownMenuRef,
            style: state.menuPositionStyle
          },
          _react2.default.createElement(
            "div",
            { className: props.dropdownMenuListClassName },
            dropdownMenuItems
          )
        );
      }

      if (state.renderHidden) {
        dropdownMenu = _react2.default.createElement(
          "div",
          { key: "concealer", className: "dropdown-menu-concealer" },
          dropdownMenu
        );
      } else if (props.transition) {
        dropdownMenu = _react2.default.createElement(
          _reactTransitionGroup.CSSTransition,
          {
            "in": state.isOpen,
            classNames: transitionName,
            timeout: {
              enter: props.transitionEnterTimeout,
              exit: props.transitionExitTimeout
            }
          },
          dropdownMenu
        );
      }

      return _react2.default.createElement(
        "span",
        {
          className: wrapperClassSet,
          tabIndex: "1",
          onBlur: this.handleWrapperBlur,
          ref: this.dropdownWrapperRef
        },
        _react2.default.cloneElement(trigger, {
          selectedItem: this.getSelectedItem(this.getSelectedID(), items),
          onTrigger: this.handleMenuToggle,
          className: props.buttonClassName,
          disabled: props.disabled
        }),
        _react2.default.createElement(
          _Portal2.default,
          { onRender: this.handleMenuRender },
          dropdownMenu
        )
      );
    }
  }]);
  return Dropdown;
}(_Util2.default.mixin(_BindMixin2.default));

Dropdown.defaultProps = {
  anchorRight: false,
  matchButtonWidth: false,
  scrollContainer: window,
  scrollContainerParentSelector: null,
  transition: false,
  transitionName: "dropdown-menu",
  transitionEnterTimeout: 250,
  transitionExitTimeout: 250,
  onItemSelection: function onItemSelection() {},
  useGemini: true,
  trigger: _react2.default.createElement(_DropdownListTrigger2.default, null),
  disabled: false
};

Dropdown.propTypes = {
  // When true, anchors the dropdown to the right of the trigger.
  anchorRight: _propTypes2.default.bool,
  // When set it will always set this property as the selected ID.
  // Notice: This property will override the initialID
  persistentID: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
  // The items to display in the dropdown.
  items: _propTypes2.default.arrayOf(_propTypes2.default.shape({
    // An optional classname for the menu item.
    className: _propTypes2.default.string,
    // A required ID for each item
    id: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]).isRequired,
    // The HTML (or text) to render for the list item.
    html: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]),
    // Whether or not the user can choose the item.
    selectable: _propTypes2.default.bool,
    // The HTML (or text) to display when the option is selected. If this is
    // not provided, the value for the `html` property will be used.
    selectedHtml: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object])
  })).isRequired,
  // The ID of the item that should be selected initially.
  initialID: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
  // When true, the width of the dropdown will match the width of the button.
  matchButtonWidth: _propTypes2.default.bool,
  // An optional callback when an item is selected. Will receive an argument
  // containing the selected item as it was supplied via the items array.
  onItemSelection: _propTypes2.default.func,
  // The nearest scrolling DOMNode that contains the dropdown. Defaults to
  // window. Also accepts a string, treated as a selector for the node.
  scrollContainer: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.string]),
  // Will attach the scroll handler to the the direct parent of scrollContainer
  // if it matches this selector. Defaults to null.
  scrollContainerParentSelector: _propTypes2.default.string,
  // Optional transition on the dropdown menu. Must be accompanied
  // by an animation or transition in CSS.
  transition: _propTypes2.default.bool,
  // The prefix of the transition classnames.
  transitionName: _propTypes2.default.string,
  // Transition lengths
  transitionEnterTimeout: _propTypes2.default.number,
  transitionExitTimeout: _propTypes2.default.number,
  trigger: _propTypes2.default.element,
  // Option to use Gemini scrollbar. Defaults to true.
  useGemini: _propTypes2.default.bool,
  // Disable dropdown
  disabled: _propTypes2.default.bool,

  // Classes:
  // Classname for the element that ther user interacts with to open menu.
  buttonClassName: _propTypes2.default.string,
  // Classname for the dropdown menu wrapper.
  dropdownMenuClassName: _propTypes2.default.string,
  // Classname for the dropdown list wrapper.
  dropdownMenuListClassName: _propTypes2.default.string,
  // Classname for the dropdown list item.
  dropdownMenuListItemClassName: _propTypes2.default.string,
  // Classname for the element that wraps the entire component.
  wrapperClassName: _propTypes2.default.string
};

module.exports = Dropdown;