"use strict";

var _extends2 = require("babel-runtime/helpers/extends");

var _extends3 = _interopRequireDefault(_extends2);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require("babel-runtime/helpers/get");

var _get3 = _interopRequireDefault(_get2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _dedupe = require("classnames/dedupe");

var _dedupe2 = _interopRequireDefault(_dedupe);

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _BindMixin = require("../Mixin/BindMixin");

var _BindMixin2 = _interopRequireDefault(_BindMixin);

var _FormControl = require("./FormControl");

var _FormControl2 = _interopRequireDefault(_FormControl);

var _Util = require("../Util/Util");

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Find a the options for a particular field in the form.
function findFieldOption(options, field) {
  var flattenedOptions = _Util2.default.flatten(options);

  return _Util2.default.find(flattenedOptions, function (fieldOption) {
    var isField = fieldOption.name === field;
    if (fieldOption.fieldType === "object" && !isField) {
      return findFieldOption(fieldOption.definition, field);
    }

    return isField;
  });
}

function mergeNewModel(stateModel, currentDefinitionModel, nextDefinitionModel) {
  var newModel = {};
  var stateModelClone = _Util2.default.extend({}, stateModel);

  // This allows us to remove fields on the model, if we remove that field from
  // the definition.
  (0, _keys2.default)(stateModelClone).forEach(function (modelKey) {
    if (!Object.prototype.hasOwnProperty.call(nextDefinitionModel, modelKey)) {
      delete stateModelClone[modelKey];
    }
  });

  // This makes sure we only update the keys that are different.
  (0, _keys2.default)(nextDefinitionModel).forEach(function (key) {
    if (currentDefinitionModel[key] !== nextDefinitionModel[key]) {
      newModel[key] = nextDefinitionModel[key];
    }
  });

  return _Util2.default.extend({}, stateModelClone, newModel);
}

var Form = function (_Util$mixin) {
  (0, _inherits3.default)(Form, _Util$mixin);
  (0, _createClass3.default)(Form, [{
    key: "methodsToBind",
    get: function get() {
      return ["getBlurChange", "getOnFocusChange", "getValueChange", "handleEvent", "handleSubmit"];
    }
  }]);

  function Form() {
    (0, _classCallCheck3.default)(this, Form);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Form.__proto__ || (0, _getPrototypeOf2.default)(Form)).call(this));

    _this.state = {
      model: {},
      editingField: "",
      erroredFields: {}
    };

    _this.submitMap = {};
    return _this;
  }

  (0, _createClass3.default)(Form, [{
    key: "componentWillMount",
    value: function componentWillMount() {
      (0, _get3.default)(Form.prototype.__proto__ || (0, _getPrototypeOf2.default)(Form.prototype), "componentWillMount", this).call(this);

      if (this.props.triggerSubmit) {
        this.props.triggerSubmit(this.handleSubmit);
      }

      this.setState({
        model: this.buildStateObj(this.props.definition, "value"),
        erroredFields: this.buildStateObj(this.props.definition, "showError")
      });
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      (0, _get3.default)(Form.prototype.__proto__ || (0, _getPrototypeOf2.default)(Form.prototype), "componentWillReceiveProps", this).call(this);

      var props = this.props;
      var state = this.state;
      var nextState = {};
      var currentModel = this.buildStateObj(props.definition, "value");
      var nextModel = this.buildStateObj(nextProps.definition, "value");
      if (!_Util2.default.isEqual(currentModel, nextModel)) {
        nextState.model = mergeNewModel(state.model, currentModel, nextModel);
      }

      if (this.props.useExternalErrors) {
        nextState.erroredFields = this.buildStateObj(nextProps.definition, "showError");
      } else {
        var currentErrors = this.buildStateObj(props.definition, "showError");
        var nextErrors = this.buildStateObj(nextProps.definition, "showError");
        if (!_Util2.default.isEqual(currentErrors, nextErrors)) {
          nextState.erroredFields = mergeNewModel(state.erroredFields, currentErrors, nextErrors);
        }
      }

      this.setState(nextState);
    }
  }, {
    key: "handleEvent",
    value: function handleEvent(eventType, fieldName, fieldValue, event) {
      var _props$onChange;

      var eventObj = { eventType: eventType, fieldName: fieldName, fieldValue: fieldValue, event: event };
      var newState = {};

      switch (eventType) {
        case "blur":
          newState = this.getBlurChange(fieldName);
          break;
        case "change":
          newState = this.getValueChange(fieldName, fieldValue);
          break;
        case "focus":
          newState = this.getOnFocusChange(fieldName);
          break;
        case "multipleChange":
          newState = this.getMultipleChange(fieldName, fieldValue);
      }

      // If there is no change to the model, just return the old one
      var newModel = newState.model || this.state.model;

      for (var _len = arguments.length, rest = Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {
        rest[_key - 4] = arguments[_key];
      }

      var onChange = (_props$onChange = this.props.onChange).bind.apply(_props$onChange, [this, newModel, eventObj].concat(rest));
      if ((0, _keys2.default)(newState).length) {
        // Make sure to call onChange on setState callback,
        // so users can get updated model from triggerSubmit
        this.setState(newState, onChange);
      } else {
        onChange();
      }
    }
  }, {
    key: "getTriggerSubmit",
    value: function getTriggerSubmit(formKey, triggerSubmit) {
      this.submitMap[formKey] = triggerSubmit;
    }
  }, {
    key: "handleSubSubmit",
    value: function handleSubSubmit(formKey, model) {
      this.state.model[formKey] = model;
    }
  }, {
    key: "handleSubmit",
    value: function handleSubmit(event) {
      var _this2 = this;

      if (event) {
        event.preventDefault();
      }

      var model = this.state.model;
      var props = this.props;
      var validated = this.validateSubmit(model, props.definition);

      (0, _keys2.default)(this.submitMap).forEach(function (formKey) {
        _this2.submitMap[formKey]();
      });

      if (!validated) {
        props.onError();
      }

      if (validated && props.onSubmit) {
        props.onSubmit(model);
      }
    }
  }, {
    key: "getValueChange",
    value: function getValueChange(field, value) {
      var model = _Util2.default.clone(this.state.model);
      model[field] = value;

      return { model: model };
    }
  }, {
    key: "getMultipleChange",
    value: function getMultipleChange(field, values) {
      var model = _Util2.default.clone(this.state.model);
      model[field].forEach(function (item) {
        var name = item.name;

        if (_Util2.default.isArray(values)) {
          values.forEach(function (value) {
            // Update value in field
            if (name === value.name) {
              _Util2.default.extend(item, value);
            }
          });
        } else if (name === values.name) {
          _Util2.default.extend(item, values);
        }
      });

      return { model: model };
    }
  }, {
    key: "getBlurChange",
    value: function getBlurChange(field) {
      var options = findFieldOption(this.props.definition, field);

      if (options.writeType === "input") {
        return {};
      }

      this.handleSubmit();

      return { editingField: null };
    }
  }, {
    key: "getOnFocusChange",
    value: function getOnFocusChange(name) {
      var fieldOption = findFieldOption(this.props.definition, name);

      if (fieldOption.writeType === "edit") {
        return { editingField: name };
      }

      return {};
    }
  }, {
    key: "validateValue",
    value: function validateValue(field, value, definition) {
      var options = findFieldOption(definition, field);

      if (options == null || options.validation == null) {
        return true;
      }

      var validation = options.validation;


      if (typeof validation === "function") {
        return validation(value);
      }

      return validation.test(value);
    }
  }, {
    key: "validateSubmit",
    value: function validateSubmit(model, definition) {
      var _this3 = this;

      var erroredFields = {};
      var submitValidated = true;

      (0, _keys2.default)(model).forEach(function (name) {
        var options = findFieldOption(definition, name);
        if (options == null) {
          return true;
        }

        var fieldValue = model[name];
        var validated = _this3.validateValue(name, fieldValue, definition);

        if (!validated) {
          erroredFields[name] = options.validationErrorText;
          submitValidated = false;

          return;
        }

        if (options.required && (fieldValue == null || fieldValue === "")) {
          erroredFields[name] = "Field cannot be empty.";
          submitValidated = false;
        }
      });

      erroredFields = _Util2.default.extend({}, this.buildStateObj(this.props.definition, "showError"), erroredFields);

      // Set the errored fields into state so we can render correctly.
      this.setState({ erroredFields: erroredFields });

      return submitValidated;
    }
  }, {
    key: "buildStateObj",
    value: function buildStateObj(definition, fieldProp) {
      var _this4 = this;

      var stateObj = {};
      _Util2.default.flatten(definition).forEach(function (formControlOption) {
        // If the element is a React element, then we don't want to add it to the
        // state object, which represents the form values.
        if (_react2.default.isValidElement(formControlOption) || formControlOption.render || formControlOption.fieldType === "submit") {
          return;
        }

        if (formControlOption.fieldType === "object") {
          stateObj[formControlOption.name] = _this4.buildStateObj(formControlOption.definition, fieldProp);

          return;
        }

        stateObj[formControlOption.name] = formControlOption[fieldProp] || null;
      });

      return stateObj;
    }
  }, {
    key: "buildFormPropObj",
    value: function buildFormPropObj(formControlOption, stateObj) {
      var name = formControlOption.name;
      var propObj = {};

      if (_Util2.default.isArray(formControlOption)) {
        formControlOption.forEach(function (option) {
          propObj[option.name] = stateObj[option.name];
        });
      } else {
        propObj[name] = stateObj[name];
      }

      return propObj;
    }
  }, {
    key: "getFormControls",
    value: function getFormControls(definition) {
      var _this5 = this;

      var props = this.props,
          state = this.state;

      var classes = {
        formGroupClass: "form-group",
        formGroupErrorClass: "form-group-danger",
        formRowClass: "row",
        helpBlockClass: "form-control-feedback",
        inlineIconClass: "form-element-inline-icon",
        inlineTextClass: "form-element-inline-text",
        inputClass: "form-control",
        readClass: "read-only"
      };

      (0, _keys2.default)(classes).forEach(function (className) {
        classes[className] = (0, _dedupe2.default)(classes[className], props[className]);
      });

      return definition.map(function (formControlOption, i) {
        // If it's a React element, we just want to return it. We need to add a
        // key to the object because we're iterating over a list of items.
        if (_react2.default.isValidElement(formControlOption)) {
          return _react2.default.createElement(
            "span",
            { key: i },
            formControlOption
          );
        }

        if (formControlOption.render && !formControlOption.definition) {
          return formControlOption.render();
        }

        if (formControlOption.fieldType === "object") {
          var nestedDefinition = [formControlOption.render()].concat(formControlOption.definition);

          return _react2.default.createElement(Form, {
            className: _this5.props.className,
            key: i,
            definition: nestedDefinition,
            triggerSubmit: _this5.getTriggerSubmit.bind(_this5, formControlOption.name),
            onChange: _this5.props.onChange,
            onSubmit: _this5.handleSubSubmit.bind(_this5, formControlOption.name),
            formTag: "div"
          });
        }

        // Map each field to showError boolean
        var showError = _this5.buildFormPropObj(formControlOption, state.erroredFields);

        // Map each field to it's current value.
        var currentValue = _this5.buildFormPropObj(formControlOption, state.model);

        return _react2.default.createElement(_FormControl2.default, (0, _extends3.default)({
          key: i,
          definition: formControlOption,
          editing: state.editingField,
          validationError: showError,
          currentValue: currentValue,
          handleEvent: _this5.handleEvent,
          handleSubmit: _this5.handleSubmit,
          maxColumnWidth: props.maxColumnWidth
        }, classes));
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _props = this.props,
          className = _props.className,
          definition = _props.definition,
          key = _props.key,
          noValidate = _props.noValidate;


      return _react2.default.createElement(
        this.props.formTag,
        {
          key: key,
          onSubmit: this.handleSubmit,
          className: (0, _dedupe2.default)("form flush-bottom", className),
          noValidate: noValidate
        },
        this.getFormControls(definition)
      );
    }
  }]);
  return Form;
}(_Util2.default.mixin(_BindMixin2.default));

var classPropType = _propTypes2.default.oneOfType([_propTypes2.default.array, _propTypes2.default.object, _propTypes2.default.string]);

Form.defaultProps = {
  definition: {},
  formTag: "form",
  key: "",
  maxColumnWidth: 12,
  onChange: function onChange() {},
  onError: function onError() {},
  onSubmit: function onSubmit() {},
  triggerSubmit: function triggerSubmit() {}
};

Form.propTypes = {
  // Classes.
  className: classPropType,
  formGroupClass: classPropType,
  formGroupErrorClass: classPropType,
  formRowClass: classPropType,
  helpBlockClass: classPropType,
  inlineIconClass: classPropType,
  inlineTextClass: classPropType,
  inputClass: classPropType,
  readClass: classPropType,
  sharedClass: classPropType,

  formTag: _propTypes2.default.string,
  key: _propTypes2.default.node,

  // Form definition to build the form from. Contains either:
  // 1. Array of field definitions will be created on same row
  // 2. Field definition (object) will create a single field in that row
  definition: _propTypes2.default.arrayOf(_propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.array])),

  // Optional number of columns in the grid
  maxColumnWidth: _propTypes2.default.number,
  // Optional function to call on error
  onError: _propTypes2.default.func,
  // Optional function to call on change
  onChange: _propTypes2.default.func,
  // Optional function to call on submit
  onSubmit: _propTypes2.default.func,
  // Optional function. Will receive a trigger function.
  // Call the trigger function, when a submit needs to be triggered externally
  triggerSubmit: _propTypes2.default.func,
  // If set to true, errors will be completely driven from the form definition.
  useExternalErrors: _propTypes2.default.bool
};

module.exports = Form;