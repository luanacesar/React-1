"use strict";

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require("babel-runtime/helpers/get");

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

var _dedupe = require("classnames/dedupe");

var _dedupe2 = _interopRequireDefault(_dedupe);

var _reactGeminiScrollbar = require("react-gemini-scrollbar");

var _reactGeminiScrollbar2 = _interopRequireDefault(_reactGeminiScrollbar);

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactTransitionGroup = require("react-transition-group");

var _BindMixin = require("../Mixin/BindMixin");

var _BindMixin2 = _interopRequireDefault(_BindMixin);

var _DOMUtil = require("../Util/DOMUtil");

var _DOMUtil2 = _interopRequireDefault(_DOMUtil);

var _Keycodes = require("../constants/Keycodes");

var _Keycodes2 = _interopRequireDefault(_Keycodes);

var _Util = require("../Util/Util");

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// This value is used to designate "off-limits" vertical space, so that the
// modal never comes into contact with the edge of the viewport.

/* eslint-enable no-unused-vars */
var MODAL_VERTICAL_INSET_DISTANCE = 48;
/**
 * Lifecycle of a Modal:
 * initial page load -> empty TransitionGroup
 * interaction changes open to true -> render modal content without scrollbars
 * get height of content -> rerender modal content and cap the height
 */

/* eslint-disable no-unused-vars */

var ModalContents = function (_Util$mixin) {
  (0, _inherits3.default)(ModalContents, _Util$mixin);

  function ModalContents() {
    (0, _classCallCheck3.default)(this, ModalContents);

    var _this = (0, _possibleConstructorReturn3.default)(this, (ModalContents.__proto__ || (0, _getPrototypeOf2.default)(ModalContents)).apply(this, arguments));

    _this.lastConstrainedHeight = null;
    _this.state = {
      height: null
    };

    _this.footerRef = _react2.default.createRef();
    _this.geminiRef = _react2.default.createRef();
    _this.headerRef = _react2.default.createRef();
    _this.innerContentContainerRef = _react2.default.createRef();
    _this.innerContentRef = _react2.default.createRef();
    _this.modalRef = _react2.default.createRef();
    return _this;
  }

  (0, _createClass3.default)(ModalContents, [{
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      (0, _get3.default)(ModalContents.prototype.__proto__ || (0, _getPrototypeOf2.default)(ModalContents.prototype), "componentWillReceiveProps", this).apply(this, arguments);

      if (this.props.open !== nextProps.open) {
        document.body.classList.toggle("no-overflow");
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      (0, _get3.default)(ModalContents.prototype.__proto__ || (0, _getPrototypeOf2.default)(ModalContents.prototype), "componentDidUpdate", this).apply(this, arguments);

      // If we don't already know the height of the content, we calculate it.
      if (this.props.open) {
        this.lastViewportHeight = Math.ceil(_DOMUtil2.default.getViewportHeight());
        global.requestAnimationFrame(this.calculateContentHeight);
      }
    }
  }, {
    key: "componentWillUpdate",
    value: function componentWillUpdate(nextProps) {
      // Reset the height of the content to null when the modal is closing so
      // that the height will be recalculated next time it opens.
      if (this.props.open && !nextProps.open) {
        this.setState({ height: null });
        this.removeKeydownListener();
      }

      if (!this.props.open && nextProps.open) {
        this.addKeydownListener();
      }
    }
  }, {
    key: "componentWillMount",
    value: function componentWillMount() {
      (0, _get3.default)(ModalContents.prototype.__proto__ || (0, _getPrototypeOf2.default)(ModalContents.prototype), "componentWillMount", this).apply(this, arguments);

      if (this.props.open) {
        document.body.classList.add("no-overflow");
      }

      window.addEventListener("resize", this.handleWindowResize);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      (0, _get3.default)(ModalContents.prototype.__proto__ || (0, _getPrototypeOf2.default)(ModalContents.prototype), "componentWillUnmount", this).apply(this, arguments);

      document.body.classList.remove("no-overflow");
      window.removeEventListener("resize", this.handleWindowResize);
    }
  }, {
    key: "handleBackdropClick",
    value: function handleBackdropClick() {
      if (this.props.closeByBackdropClick) {
        this.closeModal();
      }
    }
  }, {
    key: "handleKeyDown",
    value: function handleKeyDown(event) {
      if (event.keyCode === _Keycodes2.default.esc) {
        this.closeModal();
      }
    }
  }, {
    key: "handleWindowResize",
    value: function handleWindowResize() {
      var props = this.props,
          state = this.state;

      // Return early if the modal is closed or not using Gemini.

      if (!props.open) {
        return;
      }

      var viewportHeight = Math.ceil(_DOMUtil2.default.getViewportHeight());

      // If the height of the viewport is getting shorter, or if it's growing
      // while the height is currently constrained, then we reset the restrained
      // height to null which will cause the height to be recalculated on the
      // next render.
      if (viewportHeight < this.lastViewportHeight || viewportHeight > this.lastViewportHeight && state.height !== null) {
        this.setState({ height: null });
      }

      this.lastViewportHeight = viewportHeight;
      global.requestAnimationFrame(this.calculateContentHeight);
    }
  }, {
    key: "addKeydownListener",
    value: function addKeydownListener() {
      global.document.body.addEventListener("keydown", this.handleKeyDown);
    }
  }, {
    key: "removeKeydownListener",
    value: function removeKeydownListener() {
      global.document.body.removeEventListener("keydown", this.handleKeyDown);
    }
  }, {
    key: "calculateContentHeight",
    value: function calculateContentHeight() {
      // A full screen modal doesn't need to restrict its height.
      if (this.props.isFullScreen) {
        return;
      }

      var footerRef = this.footerRef,
          headerRef = this.headerRef,
          modalRef = this.modalRef,
          innerContentRef = this.innerContentRef,
          innerContentContainerRef = this.innerContentContainerRef;


      var headerHeight = 0;
      var footerHeight = 0;
      var modalHeight = 0;
      var innerContentHeight = 0;

      if (headerRef != null && headerRef.current != null) {
        headerHeight = Math.ceil(headerRef.current.getBoundingClientRect().height);
      }

      if (footerRef != null && footerRef.current != null) {
        footerHeight = Math.ceil(footerRef.current.getBoundingClientRect().height);
      }

      if (modalRef != null && modalRef.current != null) {
        modalHeight = Math.ceil(modalRef.current.getBoundingClientRect().height);
      }

      if (innerContentRef != null && innerContentRef.current != null) {
        innerContentHeight = Math.ceil(innerContentRef.current.getBoundingClientRect().height);
      }

      var maxModalHeight = this.lastViewportHeight - MODAL_VERTICAL_INSET_DISTANCE;

      var totalModalContentHeight = innerContentHeight + headerHeight + footerHeight;

      // When the modal's content fits on the screen, both the modal and body
      // height can be set to `auto` (default).
      var nextInnerContentContainerHeight = "auto";
      var nextModalHeight = "auto";

      // When the modal's content is too large to fit on the screen, then we need
      // to explicitly set the body's height to its exact pixel value and the
      // modal's height to `100%`.
      var shouldConstrainHeight = totalModalContentHeight >= maxModalHeight || this.lastViewportHeight < this.lastConstrainedHeight;

      if (shouldConstrainHeight) {
        var availableContentHeight = modalHeight - headerHeight - footerHeight;
        nextInnerContentContainerHeight = availableContentHeight + "px";
        nextModalHeight = "100%";

        // We need to keep track of the largest viewport height that results in a
        // constrained modal.
        if (this.lastConstrainedHeight == null || this.lastViewportHeight > this.lastConstrainedHeight) {
          this.lastConstrainedHeight = this.lastViewportHeight;
        }

        if (this.props.useGemini && this.state.height !== availableContentHeight) {
          this.setState({ height: availableContentHeight });
        }
      }

      if (innerContentContainerRef != null && innerContentContainerRef.current != null) {
        innerContentContainerRef.current.style.height = nextInnerContentContainerHeight;
      }
      if (modalRef != null && modalRef.current != null) {
        modalRef.current.style.height = nextModalHeight;
      }

      this.triggerGeminiUpdate();
    }
  }, {
    key: "closeModal",
    value: function closeModal() {
      this.props.onClose();
    }
  }, {
    key: "getCloseButton",
    value: function getCloseButton() {
      var props = this.props;


      if (props.closeButton) {
        return props.closeButton;
      }

      return null;
    }
  }, {
    key: "getHeader",
    value: function getHeader() {
      var props = this.props;


      if (props.showHeader === false) {
        return null;
      }

      return _react2.default.createElement(
        "div",
        { className: props.headerClass, ref: this.headerRef },
        props.header,
        props.subHeader
      );
    }
  }, {
    key: "getFooter",
    value: function getFooter() {
      var props = this.props;


      if (props.showFooter === false) {
        return null;
      }

      return _react2.default.createElement(
        "div",
        { className: props.footerClass, ref: this.footerRef },
        props.footer
      );
    }
  }, {
    key: "getModalContent",
    value: function getModalContent() {
      var props = this.props,
          state = this.state;


      var modalContent = _react2.default.createElement(
        "div",
        { className: props.scrollContainerClass, ref: this.innerContentRef },
        props.children
      );

      // If the consume disables gemini or we don't know the height, then we
      // don't render with Gemini, unless the consumer is using specifying a
      // custom height.
      if ((!props.useGemini || state.height == null) && props.modalHeight == null) {
        return modalContent;
      }

      var geminiClasses = (0, _dedupe2.default)("container-scrollable", props.geminiClass);
      var geminiContainerStyle = { height: state.height };

      if (props.modalHeight) {
        geminiContainerStyle.height = props.modalHeight;
      }

      return _react2.default.createElement(
        _reactGeminiScrollbar2.default,
        {
          autoshow: false,
          className: geminiClasses,
          ref: this.geminiRef,
          style: geminiContainerStyle
        },
        modalContent
      );
    }
  }, {
    key: "getModal",
    value: function getModal() {
      var props = this.props,
          state = this.state;

      var modalBodyStyle = {};

      if (!props.open) {
        return null;
      }

      if (state.height != null) {
        modalBodyStyle.height = state.height;
      }

      return _react2.default.createElement(
        "div",
        { ref: this.modalRef, className: props.modalClass },
        this.getCloseButton(),
        this.getHeader(),
        _react2.default.createElement(
          "div",
          {
            className: props.bodyClass,
            style: modalBodyStyle,
            ref: this.innerContentContainerRef
          },
          this.getModalContent()
        ),
        this.getFooter()
      );
    }
  }, {
    key: "getBackdrop",
    value: function getBackdrop() {
      var props = this.props;


      if (!props.open) {
        return null;
      }

      return _react2.default.createElement("div", { className: props.backdropClass, onClick: this.handleBackdropClick });
    }
  }, {
    key: "triggerGeminiUpdate",
    value: function triggerGeminiUpdate() {
      if (this.geminiRef != null && this.geminiRef.current != null && this.geminiRef.current.scrollbar != null) {
        this.geminiRef.current.scrollbar.update();
      }
    }
  }, {
    key: "render",
    value: function render() {
      var props = this.props;

      var modalContent = null;

      if (props.open) {
        modalContent = _react2.default.createElement(
          "div",
          { className: (0, _dedupe2.default)("modal-wrapper", props.modalWrapperClass) },
          this.getBackdrop(),
          this.getModal()
        );
      }

      return _react2.default.createElement(
        _reactTransitionGroup.CSSTransition,
        {
          "in": props.open,
          appear: props.transitionAppear,
          enter: props.transitionEnter,
          exit: props.transitionExit,
          classNames: props.transitionNameModal,
          timeout: {
            enter: props.transitionEnterTimeout,
            exit: props.transitionExitTimeout,
            appear: props.transitionAppearTimeoutModal
          }
        },
        _react2.default.createElement(
          "div",
          null,
          modalContent
        )
      );
    }
  }, {
    key: "methodsToBind",
    get: function get() {
      return ["calculateContentHeight", "closeModal", "handleBackdropClick", "handleKeyDown", "handleWindowResize"];
    }
  }]);
  return ModalContents;
}(_Util2.default.mixin(_BindMixin2.default));

ModalContents.defaultProps = {
  closeByBackdropClick: true,
  footer: null,
  header: null,
  isFullScreen: false,
  onClose: function onClose() {},
  open: false,
  showHeader: false,
  showFooter: false,
  subHeader: null,
  transitionNameModal: "modal",
  transitionAppearTimeoutModal: 300,
  transitionEnterTimeoutModal: 300,
  transitionExitTimeoutModal: 300,
  transitionAppear: true,
  transitionEnter: true,
  transitionExit: true,
  useGemini: true,

  // Default classes.
  backdropClass: "modal-backdrop",
  bodyClass: "modal-body-wrapper",
  closeButtonClass: "modal-close",
  footerClass: "modal-footer",
  headerClass: "modal-header",
  modalClass: "modal modal-large",
  scrollContainerClass: "modal-body"
};

ModalContents.propTypes = {
  children: _propTypes2.default.node,
  // Appends whatever value is provided as a close button.
  closeButton: _propTypes2.default.node,
  // Allow closing of modal when click happens outside modal. Defaults to true.
  closeByBackdropClick: _propTypes2.default.bool,
  // Allow resize of modal to fit screen. Defaults to true.
  // Optional footer
  footer: _propTypes2.default.object,
  // Optional header.
  header: _propTypes2.default.node,
  // Optionally set full screen modal to avoid content height restrictions.
  isFullScreen: _propTypes2.default.bool,
  // Specify a custom modal height.
  modalHeight: _propTypes2.default.string,
  // Optional callback function exected when modal is closed.
  onClose: _propTypes2.default.func,
  // True if modal is open, false otherwise.
  open: _propTypes2.default.bool,
  // Set true to show header. Defaults to false.
  showHeader: _propTypes2.default.bool,
  // Set true to show footer. Defaults to false.
  showFooter: _propTypes2.default.bool,
  // Optional subheader.
  subHeader: _propTypes2.default.node,
  // Optional enter and leave transition name for modal
  transitionNameModal: _propTypes2.default.string,
  // Transition lengths, must be non-zero
  transitionAppearTimeoutModal: _propTypes2.default.number,
  transitionEnterTimeoutModal: _propTypes2.default.number,
  transitionExitTimeoutModal: _propTypes2.default.number,
  // Optionally disable transitions
  transitionAppear: _propTypes2.default.bool,
  transitionEnter: _propTypes2.default.bool,
  transitionExit: _propTypes2.default.bool,
  // Option to use Gemini scrollbar. Defaults to true.
  useGemini: _propTypes2.default.bool,

  // Classes
  backdropClass: _propTypes2.default.string,
  bodyClass: _propTypes2.default.string,
  closeButtonClass: _propTypes2.default.string,
  footerClass: _propTypes2.default.string,
  geminiClass: _propTypes2.default.oneOfType([_propTypes2.default.array, _propTypes2.default.object, _propTypes2.default.string]),
  headerClass: _propTypes2.default.string,
  modalClass: _propTypes2.default.string,
  modalWrapperClass: _propTypes2.default.string,
  scrollContainerClass: _propTypes2.default.string
};

module.exports = ModalContents;