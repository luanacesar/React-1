"use strict";

var _extends2 = require("babel-runtime/helpers/extends");

var _extends3 = _interopRequireDefault(_extends2);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

var _classnames = require("classnames");

var _classnames2 = _interopRequireDefault(_classnames);

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = require("react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _DOMUtil = require("../Util/DOMUtil");

var _DOMUtil2 = _interopRequireDefault(_DOMUtil);

var _Util = require("../Util/Util");

var _Util2 = _interopRequireDefault(_Util);

var _VirtualList = require("../VirtualList/VirtualList");

var _VirtualList2 = _interopRequireDefault(_VirtualList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MAX_CACHE_SIZE = 10000;

var sortData = function sortData(columns, data, sortBy) {
  if (sortBy.order === undefined || sortBy.prop === undefined) {
    return data;
  }

  var sortFunction = void 0;

  columns.forEach(function (column) {
    if (column.prop === sortBy.prop) {
      sortFunction = column.sortFunction;
    }
  });

  if (sortFunction) {
    // Use custom sort method if specified.
    data = _Util2.default.sortBy(data, sortFunction(sortBy.prop, sortBy.order));
  } else {
    // Otherwise, use default sorting.
    data = _Util2.default.sortBy(data, sortBy.prop);
  }

  if (sortBy.order === "desc") {
    data.reverse();
  }

  return data;
};

var getClassName = function getClassName(column, sortBy, data, columns) {
  if (_Util2.default.isFunction(column.className)) {
    return column.className(column.prop, sortBy, data, columns);
  }

  return column.className || "";
};

var Table = function (_React$Component) {
  (0, _inherits3.default)(Table, _React$Component);

  function Table() {
    (0, _classCallCheck3.default)(this, Table);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Table.__proto__ || (0, _getPrototypeOf2.default)(Table)).apply(this, arguments));

    _this.state = {
      sortBy: {}
    };
    _this.cachedCells = {};
    _this.cachedIDs = [];
    _this.container = window;

    _this.containerRef = _react2.default.createRef();
    _this.headersRef = _react2.default.createRef();
    _this.itemHeightContainer = _react2.default.createRef();
    return _this;
  }

  (0, _createClass3.default)(Table, [{
    key: "componentWillMount",
    value: function componentWillMount() {
      if (this.props.sortBy != null) {
        this.setState({ sortBy: this.props.sortBy }, this.handleSort.bind(this, this.props.sortBy.prop, { toggle: false }));
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateHeight();
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps() {
      this.updateHeight();

      if (this.props.sortBy.prop) {
        this.handleSort(this.props.sortBy.prop, { toggle: false });
      }
    }
  }, {
    key: "checkFullCache",
    value: function checkFullCache() {
      if (this.cachedIDs.length < MAX_CACHE_SIZE) {
        return;
      }

      var lastID = this.cachedIDs.shift();
      delete this.cachedCells[lastID];
    }
  }, {
    key: "addToCache",
    value: function addToCache(id, element) {
      this.cachedCells[id] = element;
      this.cachedIDs.push(id);
      this.checkFullCache();
    }
  }, {
    key: "updateHeight",
    value: function updateHeight() {
      var props = this.props,
          state = this.state;


      if (props.containerSelector && this.container === window) {
        this.container = _DOMUtil2.default.closest(_reactDom2.default.findDOMNode(this), props.containerSelector) || window;
      }

      if (props.itemHeight == null && state.itemHeight == null && this.itemHeightContainer && this.itemHeightContainer.current) {
        // Calculate content height only once and when node is ready
        var itemHeight = _DOMUtil2.default.getComputedDimensions(_reactDom2.default.findDOMNode(this.itemHeightContainer.current).querySelector("tr")).height;
        this.setState({ itemHeight: itemHeight });
      }
    }
  }, {
    key: "buildUniqueID",
    value: function buildUniqueID(cellClassName, cellValue, prop) {
      return prop + cellClassName + cellValue;
    }
  }, {
    key: "getHeaders",
    value: function getHeaders(headers, sortBy) {
      var _this2 = this;

      var buildSortAttributes = function buildSortAttributes(header) {
        var sortEvent = _this2.handleSort.bind(_this2, header.prop);

        return {
          onClick: sortEvent,
          tabIndex: 0,
          "aria-sort": _this2.state.sortBy.order,
          "aria-label": header.prop + ": activate to sort column " + _this2.state.sortBy.order
        };
      };

      return headers.map(function (header, index) {
        var order = void 0,
            heading = void 0;
        var attributes = {};

        // Only add sorting events if the column has a value for 'prop'
        // and the 'sorting' property is true.
        if (header.sortable !== false && "prop" in header) {
          attributes = buildSortAttributes(header);
          order = _this2.state.sortBy.order;
        }

        // If the heading property is a method, then pass to it the options and
        // render the result. Otherwise, display the value.
        if (_Util2.default.isFunction(header.heading)) {
          heading = header.heading(header.prop, order, sortBy);
        } else {
          heading = header.heading;
        }

        attributes.className = getClassName(header, _this2.state.sortBy, null, _this2.props.columns);
        attributes.key = index;

        return _react2.default.createElement(
          "th",
          attributes,
          heading
        );
      });
    }
  }, {
    key: "getBufferItem",
    value: function getBufferItem(columns, styles) {
      return _react2.default.createElement(
        "tr",
        { style: styles },
        _react2.default.createElement("td", { colSpan: columns.length })
      );
    }
  }, {
    key: "getEmptyRowCell",
    value: function getEmptyRowCell(columns) {
      return _react2.default.createElement(
        "tr",
        null,
        _react2.default.createElement(
          "td",
          { colSpan: columns.length },
          this.props.emptyMessage
        )
      );
    }
  }, {
    key: "getCellValue",
    value: function getCellValue(row, prop, column) {
      var getValue = column.getValue;

      if (getValue && typeof getValue === "function") {
        return getValue(row, prop);
      }

      return row[prop];
    }
  }, {
    key: "getRowCells",
    value: function getRowCells(columns, sortBy, buildRowOptions, row, rowIndex) {
      var _this3 = this;

      var rowCells = columns.map(function (column, index) {
        var cellClassName = getClassName(column, sortBy, row, columns);
        var prop = column.prop;
        var cellValue = _this3.getCellValue(row, prop, column);
        var cellID = void 0;

        if (column.cacheCell === true) {
          cellID = _this3.buildUniqueID(cellClassName, cellValue, prop);
        }

        // Skip build cell if we have it memoized
        if (cellID === undefined || _this3.cachedCells[cellID] == null) {
          if (column.render) {
            cellValue = column.render(prop, row);
          }

          if (cellValue === undefined) {
            cellValue = column.defaultContent;
            cellClassName += " empty-cell";
          }

          var cellElement = _react2.default.createElement(
            "td",
            (0, _extends3.default)({}, column.attributes, { className: cellClassName, key: index }),
            cellValue
          );

          if (!column.cacheCell) {
            return cellElement;
          }

          _this3.addToCache(cellID, cellElement);
        }

        return _this3.cachedCells[cellID];
      });

      return _react2.default.createElement(
        "tr",
        (0, _extends3.default)({ key: rowIndex }, buildRowOptions(row, this)),
        rowCells
      );
    }
  }, {
    key: "handleSort",
    value: function handleSort(prop, options) {
      var sortBy = this.state.sortBy;
      var onSortCallback = this.props.onSortCallback;
      options = _Util2.default.extend({
        toggle: true
      }, options);

      if (options.toggle) {
        var order = void 0;

        if (sortBy.order === "desc" || sortBy.prop !== prop) {
          order = "asc";
        } else {
          order = "desc";
        }

        this.setState({
          sortBy: { order: order, prop: prop }
        });
      }

      if (_Util2.default.isFunction(onSortCallback)) {
        onSortCallback(sortBy);
      }
    }
  }, {
    key: "getTBody",
    value: function getTBody(columns, data, sortBy, itemHeight) {
      var _this4 = this;

      var _props = this.props,
          buildRowOptions = _props.buildRowOptions,
          virtualizeDataThreshold = _props.virtualizeDataThreshold;

      var childToMeasure = void 0;

      if (itemHeight === 0 && data.length) {
        childToMeasure = this.getRowCells(columns, sortBy, buildRowOptions, data[0], -1);

        return _react2.default.createElement(
          "tbody",
          { ref: this.itemHeightContainer },
          childToMeasure
        );
      }

      if (data.length === 0) {
        return _react2.default.createElement(
          "tbody",
          null,
          this.getEmptyRowCell(columns)
        );
      }

      var sortedData = sortData(columns, data, sortBy);

      if (data.length < virtualizeDataThreshold) {
        // Do not use virtual list for "small" data sets
        return _react2.default.createElement(
          "tbody",
          null,
          sortedData.map(function (item, index) {
            return _this4.getRowCells(columns, sortBy, buildRowOptions, item, index);
          })
        );
      }

      return _react2.default.createElement(_VirtualList2.default, {
        className: "table-virtual-list",
        container: this.container,
        itemBuffer: 70,
        itemHeight: itemHeight,
        items: sortedData,
        renderBufferItem: this.getBufferItem.bind(this, columns),
        renderItem: this.getRowCells.bind(this, columns, sortBy, buildRowOptions),
        scrollDelay: 200,
        tagName: "tbody"
      });
    }
  }, {
    key: "render",
    value: function render() {
      var props = this.props,
          state = this.state;
      var columns = props.columns,
          data = props.data;

      var classes = (0, _classnames2.default)(props.className, "flush-bottom");
      var sortBy = state.sortBy;
      var itemHeight = state.itemHeight || props.itemHeight || 0;

      return _react2.default.createElement(
        "div",
        { ref: this.containerRef },
        _react2.default.createElement(
          "table",
          { ref: this.headersRef, className: classes },
          props.colGroup,
          _react2.default.createElement(
            "thead",
            null,
            _react2.default.createElement(
              "tr",
              null,
              this.getHeaders(columns, sortBy)
            )
          ),
          this.getTBody(columns, data, sortBy, itemHeight)
        )
      );
    }
  }]);
  return Table;
}(_react2.default.Component);

Table.defaultProps = {
  buildRowOptions: function buildRowOptions() {
    return {};
  },
  sortBy: {},
  emptyMessage: "No data",
  virtualizeDataThreshold: 1000
};

Table.propTypes = {
  // Optional attributes to be passed to the row elements.
  buildRowOptions: _propTypes2.default.func,

  className: _propTypes2.default.string,

  // Optional colgroup component.
  colGroup: _propTypes2.default.object,

  // Define how columns should be rendered and if they are sortable.
  columns: _propTypes2.default.arrayOf(_propTypes2.default.shape({
    // Attributes to pass down to each column item.
    attributes: _propTypes2.default.object,

    // Class to give to each column item.
    // Can be a function to programmatically create a class.
    className: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),

    // Content to default to in the case of no data for the prop.
    defaultContent: _propTypes2.default.string,

    // Enable caching of cells for better performance. Not cached by default.
    cacheCell: _propTypes2.default.bool,

    // Function to render the header of the column. Can also be a string.
    // The arguments to the function will be:
    // prop (prop to sort by), order (asc/desc), sortBy (the sort function)
    heading: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]).isRequired,

    // What prop of the data object to use.
    prop: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),

    // If true, the column will sort on column heading click.
    sortable: _propTypes2.default.bool,

    // Custom sorting function. If this function returns null,
    // it will fallback to default sorting.
    sortFunction: _propTypes2.default.func
  })).isRequired,

  // Optional selector of the parent element that has a scrollbar in order to
  // listen to its scroll event.
  containerSelector: _propTypes2.default.string,

  // Data to display in the table.
  // Make sure to clone the data, cannot be modified!
  data: _propTypes2.default.array.isRequired,

  // Text to show if there is no data.
  emptyMessage: _propTypes2.default.string,

  // Optional item height for the scroll table. If not provided, it will render
  // once to measure the height of the first child.
  // NB: Initial render will stop any ongoing animation, if this is not provided
  itemHeight: _propTypes2.default.number,

  // Optional callback function when sorting is complete.
  onSortCallback: _propTypes2.default.func,

  // Optional default sorting criteria.
  sortBy: _propTypes2.default.shape({
    order: _propTypes2.default.oneOf(["asc", "desc"]),
    prop: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number])
  }),

  // Optional cutoff at which to begin rendering a virtualized list
  virtualizeDataThreshold: _propTypes2.default.number
};

module.exports = Table;