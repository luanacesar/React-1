"use strict";

var _extends2 = require("babel-runtime/helpers/extends");

var _extends3 = _interopRequireDefault(_extends2);

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

var _classnames = require("classnames");

var _classnames2 = _interopRequireDefault(_classnames);

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _BindMixin = require("../Mixin/BindMixin");

var _BindMixin2 = _interopRequireDefault(_BindMixin);

var _DOMUtil = require("../Util/DOMUtil");

var _DOMUtil2 = _interopRequireDefault(_DOMUtil);

var _Portal = require("../Portal/Portal");

var _Portal2 = _interopRequireDefault(_Portal);

var _Util = require("../Util/Util");

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ARROW_SIZE = 7;

var Tooltip = function (_Util$mixin) {
  (0, _inherits3.default)(Tooltip, _Util$mixin);
  (0, _createClass3.default)(Tooltip, [{
    key: "methodsToBind",
    get: function get() {
      return ["dismissTooltip", "getIdealLocation", "handleMouseEnter", "handleMouseLeave", "handleTooltipMouseEnter", "handleTooltipMouseLeave", "triggerClose"];
    }
  }]);

  function Tooltip() {
    (0, _classCallCheck3.default)(this, Tooltip);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Tooltip.__proto__ || (0, _getPrototypeOf2.default)(Tooltip)).apply(this, arguments));

    _this.state = { isOpen: false, wasTriggeredClose: false };

    _this.tooltipNode = _react2.default.createRef();
    _this.triggerNode = _react2.default.createRef();
    return _this;
  }

  (0, _createClass3.default)(Tooltip, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.removeScrollListener();
    }
  }, {
    key: "handleMouseEnter",
    value: function handleMouseEnter() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var props = this.props;


      if (props.suppress && !options.forceOpen) {
        return;
      }

      var _getIdealLocation = this.getIdealLocation(props.anchor, props.position),
          anchor = _getIdealLocation.anchor,
          position = _getIdealLocation.position,
          coordinates = _getIdealLocation.coordinates;

      this.setState({
        anchor: anchor,
        isOpen: true,
        position: position,
        coordinates: coordinates,
        wasTriggeredClose: false
      });
      this.addScrollListener();
    }
  }, {
    key: "handleMouseLeave",
    value: function handleMouseLeave() {
      this.dismissTooltip();
    }
  }, {
    key: "handleTooltipMouseEnter",
    value: function handleTooltipMouseEnter() {
      if (this.props.interactive && !this.state.wasTriggeredClose) {
        this.setState({ isOpen: true });
        this.addScrollListener();
      }
    }
  }, {
    key: "handleTooltipMouseLeave",
    value: function handleTooltipMouseLeave() {
      this.dismissTooltip();
    }
  }, {
    key: "addScrollListener",
    value: function addScrollListener() {
      global.addEventListener("scroll", this.dismissTooltip, true);
    }
  }, {
    key: "dismissTooltip",
    value: function dismissTooltip() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if ((!this.props.stayOpen || options.forceClose) && this.state.isOpen) {
        this.setState({ isOpen: false });
        this.removeScrollListener();
      }
    }
  }, {
    key: "getAnchor",
    value: function getAnchor(isVertical, anchor, clearance, tooltipWidth, tooltipHeight) {
      // Calculate the ideal anchor.
      if (isVertical) {
        return this.transformAnchor(anchor, clearance.left, clearance.right, tooltipWidth, clearance.boundingRect.width);
      }

      return this.transformAnchor(anchor, clearance.top, clearance.bottom, tooltipHeight, clearance.boundingRect.height);
    }
  }, {
    key: "getCoordinates",
    value: function getCoordinates(position, clearance, tooltipWidth, tooltipHeight) {
      // Calculate the coordinates of the tooltip content.
      if (position === "top") {
        return {
          left: clearance.boundingRect.left + clearance.boundingRect.width / 2,
          top: clearance.boundingRect.top - tooltipHeight + ARROW_SIZE
        };
      } else if (position === "right") {
        return {
          left: clearance.boundingRect.right,
          top: clearance.boundingRect.top + clearance.boundingRect.height / 2
        };
      } else if (position === "bottom") {
        return {
          left: clearance.boundingRect.left + clearance.boundingRect.width / 2,
          top: clearance.boundingRect.bottom
        };
      }

      return {
        left: clearance.boundingRect.left - tooltipWidth + ARROW_SIZE,
        top: clearance.boundingRect.top + clearance.boundingRect.height / 2
      };
    }
  }, {
    key: "isVertical",
    value: function isVertical(position) {
      return position !== "left" && position !== "right";
    }
  }, {
    key: "getPosition",
    value: function getPosition(position, clearance, tooltipWidth, tooltipHeight) {
      // Change the position if the tooltip will be rendered off the screen.
      if (position === "left" && clearance.left < tooltipWidth) {
        position = "right";
      } else if (position === "right" && clearance.right < tooltipWidth) {
        position = "left";
      }

      if (position === "top" && clearance.top < tooltipHeight) {
        position = "bottom";
      } else if (position === "bottom" && clearance.bottom < tooltipHeight) {
        position = "top";
      }

      return position;
    }
  }, {
    key: "getIdealLocation",
    value: function getIdealLocation(anchor, position) {
      if (!this.triggerNode || !this.triggerNode.current || !this.tooltipNode || !this.tooltipNode.current) {
        return {
          anchor: "center",
          position: "top",
          coordinates: { left: 0, top: 0 }
        };
      }

      var isVertical = this.isVertical(position);
      var clearance = _DOMUtil2.default.getNodeClearance(this.triggerNode.current);
      var tooltipRect = this.tooltipNode.current.getBoundingClientRect();
      var tooltipHeight = tooltipRect.height + ARROW_SIZE;
      var tooltipWidth = tooltipRect.width + ARROW_SIZE;

      anchor = this.getAnchor(isVertical, anchor, clearance, tooltipWidth, tooltipHeight);
      position = this.getPosition(position, clearance, tooltipWidth, tooltipHeight);

      var coordinates = this.getCoordinates(position, clearance, tooltipWidth, tooltipHeight);

      return { anchor: anchor, position: position, coordinates: coordinates };
    }
  }, {
    key: "removeScrollListener",
    value: function removeScrollListener() {
      global.removeEventListener("scroll", this.dismissTooltip, true);
    }
  }, {
    key: "triggerClose",
    value: function triggerClose() {
      this.setState({ wasTriggeredClose: true });
      this.dismissTooltip({ forceClose: true });
    }
  }, {
    key: "triggerOpen",
    value: function triggerOpen() {
      this.handleMouseEnter({ forceOpen: true });
    }
  }, {
    key: "transformAnchor",
    value: function transformAnchor(anchor, clearanceStart, clearanceEnd, tooltipDimension, triggerDimension) {
      // Change the provided anchor based on the clearance available.
      if (anchor === "start" && clearanceEnd < tooltipDimension) {
        return "end";
      }

      if (anchor === "end" && clearanceStart < tooltipDimension) {
        return "start";
      }

      if (anchor === "center") {
        var tooltipOverflow = (tooltipDimension - triggerDimension) / 2;

        if (clearanceStart < tooltipOverflow) {
          return "start";
        }

        if (clearanceEnd < tooltipOverflow) {
          return "end";
        }
      }

      return anchor;
    }
  }, {
    key: "render",
    value: function render() {
      var props = this.props,
          state = this.state;

      var tooltipStyle = {};

      // Get the anchor and position from state if possible. If not, get it from
      // the props.
      var anchor = state.anchor || props.anchor;
      var position = state.position || props.position;
      // Pass along any props that aren't specific to the Tooltip.
      var elementProps = _Util2.default.exclude(props, (0, _keys2.default)(Tooltip.propTypes));

      var tooltipClasses = (0, _classnames2.default)(props.className, "anchor-" + anchor, "position-" + position, {
        "is-interactive": props.interactive,
        "is-open": state.isOpen,
        "no-wrap": !props.wrapText
      });

      if (state.coordinates) {
        tooltipStyle = {
          left: state.coordinates.left,
          top: state.coordinates.top
        };
      }

      if (props.width) {
        tooltipStyle.width = props.width;
      }

      if (props.maxWidth) {
        tooltipStyle.maxWidth = props.maxWidth;
      }

      return _react2.default.createElement(
        props.elementTag,
        (0, _extends3.default)({
          className: props.wrapperClassName,
          onMouseEnter: this.handleMouseEnter,
          onMouseLeave: this.handleMouseLeave
        }, elementProps, {
          ref: this.triggerNode
        }),
        props.children,
        _react2.default.createElement(
          _Portal2.default,
          null,
          _react2.default.createElement(
            "div",
            {
              className: tooltipClasses,
              ref: this.tooltipNode,
              style: tooltipStyle,
              onMouseEnter: this.handleTooltipMouseEnter,
              onMouseLeave: this.handleTooltipMouseLeave
            },
            _react2.default.createElement(
              "div",
              { className: props.contentClassName },
              props.content
            )
          )
        )
      );
    }
  }]);
  return Tooltip;
}(_Util2.default.mixin(_BindMixin2.default));

Tooltip.defaultProps = {
  anchor: "center",
  className: "tooltip",
  contentClassName: "tooltip-content",
  elementTag: "div",
  interactive: false,
  position: "top",
  stayOpen: false,
  suppress: false,
  wrapperClassName: "tooltip-wrapper text-align-center",
  wrapText: false
};

Tooltip.propTypes = {
  // Anchor the tooltip to an edge of the tooltip trigger. Start and end refer
  // to the logical respective edges of the tooltip. When tooltip is positioned
  // on the right, start refers to the top of the tooltip. When tooltip is
  // positioned on the bottom, start refers to the left edge of the tooltip.
  anchor: _propTypes2.default.oneOf(["start", "center", "end"]),
  // The children will be used as the trigger.
  children: _propTypes2.default.node.isRequired,
  className: _propTypes2.default.string,
  // The tooltip's content.
  content: _propTypes2.default.node.isRequired,
  // The type of node rendered.
  elementTag: _propTypes2.default.string,
  // Allows user interaction on tooltips. When false, the tooltip is dismissed
  // when the mouse leaves the trigger. When true, the mouse is allowed to enter
  // the tooltip. Default is false.
  interactive: _propTypes2.default.bool,
  maxWidth: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
  // Position the tooltip on an edge of the tooltip trigger. Default is top.
  position: _propTypes2.default.oneOf(["top", "bottom", "right", "left"]),
  // Keeps a tooltip open after it's triggered. Defaults to false.
  stayOpen: _propTypes2.default.bool,
  // Prevents a tooltip from being displayed. Defaults to false.
  suppress: _propTypes2.default.bool,
  // Explicitly set the width of the tooltip. Default is auto.
  width: _propTypes2.default.number,
  wrapperClassName: _propTypes2.default.string,
  // Allow the text content to wrap. Default is false.
  wrapText: _propTypes2.default.bool,
  contentClassName: _propTypes2.default.string
};

module.exports = Tooltip;