"use strict";

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Functions from lodash 4.0.0-pre

/**
 * The base implementation of `_.pick` without support for individual
 * property names.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} props The property names to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, props) {
  object = Object(object);

  var length = props.length;

  var result = {};
  var index = -1;

  while (++index < length) {
    var key = props[index];
    if (key in object) {
      result[key] = object[key];
    }
  }

  return result;
}

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  var length = props.length;

  var result = Array(length);
  var index = -1;

  while (++index < length) {
    result[index] = object[props[index]];
  }

  return result;
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  return isObjectLike(value) && isArrayLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @category Lang
 * @param {*} value The value to check.
 * @return {Boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && value.length && !(typeof value === "function" && Object.prototype.toString.call(value) === "[object Function]") && (typeof value === "undefined" ? "undefined" : (0, _typeof3.default)(value)) === "object";
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  return ((typeof value === "undefined" ? "undefined" : (0, _typeof3.default)(value)) === "object" || typeof value === "function") && Object.prototype.toString.call(value) === "[object Function]";
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && (typeof value === "undefined" ? "undefined" : (0, _typeof3.default)(value)) === "object";
}

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [props] The property names to pick, specified
 *  individually or in arrays.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'user': 'fred', 'age': 40 };
 *
 * _.pick(object, 'user');
 * // => { 'user': 'fred' }
 */
function pick(object, props) {
  return object === null ? {} : basePick(object, baseFlatten(props));
}

/**
 * Creates an array of the own enumerable property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object ? baseValues(object, (0, _keys2.default)(object)) : [];
}

// Functions from Underscore 1.9.0

// Internal recursive comparison function for `isEqual`.
function eq(a, b, aStack, bStack) {
  // Identical objects are equal. `0 === -0`, but they aren't identical.
  // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
  if (a === b) {
    return a !== 0 || 1 / a === 1 / b;
  }
  // A strict comparison is necessary because `null == undefined`.
  if (a == null || b == null) {
    return a === b;
  }
  // `NaN`s are equivalent, but non-reflexive.
  /* eslint-disable no-self-compare */
  if (a !== a) {
    return b !== b;
  }
  /* eslint-enable no-self-compare */
  // Exhaust primitive checks
  var type = typeof a === "undefined" ? "undefined" : (0, _typeof3.default)(a);
  if (type !== "function" && type !== "object" && (typeof b === "undefined" ? "undefined" : (0, _typeof3.default)(b)) !== "object") {
    return false;
  }

  return deepEq(a, b, aStack, bStack);
}

// Internal recursive comparison function for `isEqual`.
function deepEq(a, b, aStack, bStack) {
  // Compare `[[Class]]` names.
  var className = Object.prototype.toString.call(a);
  if (className !== Object.prototype.toString.call(b)) {
    return false;
  }

  /* eslint-disable no-fallthrough */
  switch (className) {
    // Strings, numbers, regular expressions, dates, and booleans are compared by value.
    case "[object RegExp]":
    // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
    case "[object String]":
      // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
      // equivalent to `new String("5")`.
      return "" + a === "" + b;
    case "[object Number]":
      // `NaN`s are equivalent, but non-reflexive.
      // Object(NaN) is equivalent to NaN
      if (+a !== +a) {
        return +b !== +b;
      }

      // An `egal` comparison is performed for other numeric values.
      return +a === 0 ? 1 / +a === 1 / b : +a === +b;
    case "[object Date]":
    case "[object Boolean]":
      // Coerce dates and booleans to numeric primitive values. Dates are compared by their
      // millisecond representations. Note that invalid dates with millisecond representations
      // of `NaN` are not equivalent.
      return +a === +b;
    /* eslint-enable no-fallthrough */
  }

  var areArrays = className === "[object Array]";
  if (!areArrays) {
    if ((typeof a === "undefined" ? "undefined" : (0, _typeof3.default)(a)) != "object" || (typeof b === "undefined" ? "undefined" : (0, _typeof3.default)(b)) != "object") {
      return false;
    }

    // Objects with different constructors are not equivalent, but `Object`s or `Array`s
    // from different frames are.
    var aCtor = a.constructor,
        bCtor = b.constructor;
    if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && "constructor" in a && "constructor" in b) {
      return false;
    }
  }
  // Assume equality for cyclic structures. The algorithm for detecting cyclic
  // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

  // Initializing stack of traversed objects.
  // It's done here since we only need them for objects and arrays comparison.
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    // Linear search. Performance is inversely proportional to the number of
    // unique nested structures.
    if (aStack[length] === a) {
      return bStack[length] === b;
    }
  }

  // Add the first object to the stack of traversed objects.
  aStack.push(a);
  bStack.push(b);

  // Recursively compare objects and arrays.
  if (areArrays) {
    // Compare array lengths to determine if a deep comparison is necessary.
    length = a.length;
    if (length !== b.length) {
      return false;
    }
    // Deep compare the contents, ignoring non-numeric properties.
    while (length--) {
      if (!eq(a[length], b[length], aStack, bStack)) {
        return false;
      }
    }
  } else {
    // Deep compare objects.
    var keys = (0, _keys2.default)(a),
        key;
    length = keys.length;
    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if ((0, _keys2.default)(b).length !== length) {
      return false;
    }
    while (length--) {
      // Deep compare each member
      key = keys[length];
      if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) {
        return false;
      }
    }
  }
  // Remove the first object from the stack of traversed objects.
  aStack.pop();
  bStack.pop();

  return true;
}

function property(key) {
  return function (obj) {
    /* eslint-disable no-void */
    return obj == null ? void 0 : obj[key];
    /* eslint-enable no-void */
  };
}

// Helper for collection methods to determine whether a collection
// should be iterated as an array or as an object
var getLength = property("length");

// Internal implementation of a recursive `flatten` function.
function baseFlatten(input, shallow, strict, output) {
  output = output || [];
  var idx = output.length;
  for (var i = 0, length = getLength(input); i < length; i++) {
    var value = input[i];
    if (isArrayLike(value) && (isArray(value) || isArguments(value))) {
      // flatten current level of array or arguments object
      if (shallow) {
        var j = 0,
            len = value.length;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else {
        baseFlatten(value, shallow, strict, output);
        idx = output.length;
      }
    } else if (!strict) {
      output[idx++] = value;
    }
  }

  return output;
}

// Flatten out an array, either recursively (by default), or just one level.
function flatten(array, shallow) {
  return baseFlatten(array, shallow, false);
}

// Shortcut function for checking if an object has a given property directly
// on itself (in other words, not on a prototype).
function has(obj, key) {
  return obj != null && hasOwnProperty.call(obj, key);
}

// Perform a deep comparison to check if two objects are equal.
function isEqual(a, b) {
  return eq(a, b);
}

// Custom functions created for reactjs-components

function clone(object) {
  if (object === null || (typeof object === "undefined" ? "undefined" : (0, _typeof3.default)(object)) != "object") {
    return object;
  }
  var copy = object.constructor();
  for (var attr in object) {
    if (Object.prototype.hasOwnProperty.call(object, attr)) {
      copy[attr] = object[attr];
    }
  }

  return copy;
}

/**
 * Excludes given properties from object
 *
 * @param  {Object} object
 * @param  {Array} props Array of properties to remove
 * @return {Object} New object without given props
 */
function exclude(object, props) {
  var newObject = {};

  (0, _keys2.default)(object).forEach(function (prop) {
    if (props.indexOf(prop) === -1) {
      newObject[prop] = object[prop];
    }
  });

  return newObject;
}
function extend(object) {
  for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  sources.forEach(function (source) {
    if (Object.prototype.toString.call(source) !== "[object Object]") {
      return;
    }

    (0, _keys2.default)(source).forEach(function (key) {
      object[key] = source[key];
    });
  });

  return object;
}

function find(objects, predicate) {
  var result = void 0;
  objects.some(function (object) {
    if (predicate(object)) {
      result = object;
    }
  });

  return result || {};
}

var isArray = function isArray(arg) {
  return Object.prototype.toString.call(arg) === "[object Array]";
};

function sortBy(collection, sortProp) {
  if (isFunction(sortProp)) {
    return collection.slice().sort(sortProp);
  } else {
    return collection.slice().sort(function (a, b) {
      var keyA = a[sortProp];
      var keyB = b[sortProp];
      if (keyA < keyB) {
        return -1;
      } else if (keyA > keyB) {
        return 1;
      } else {
        return 0;
      }
    });
  }
}

/*
 * From: https://raw.githubusercontent.com/angus-c/es6-react-mixins/master/src/mixin.js
 * Based on: https://gist.github.com/sebmarkbage/fac0830dbb13ccbff596
 * by Sebastian Markbåge
 *
 * This is not the original file, and has been modified
 */

var lifecycleFunctions = ["componentWillMount", "componentDidMount", "componentWillReceiveProps", "componentWillUpdate", "componentDidUpdate", "componentWillUnmount", "render"];

function noop() {
  return null;
}
function trueNoop() {
  return true;
}

function es6ify(mixin) {
  if (typeof mixin === "function") {
    // mixin is already es6 style
    return mixin;
  }

  return function (Base) {
    // mixin is old-react style plain object
    // convert to ES6 class
    var MixinClass = function (_Base) {
      (0, _inherits3.default)(MixinClass, _Base);

      function MixinClass() {
        (0, _classCallCheck3.default)(this, MixinClass);
        return (0, _possibleConstructorReturn3.default)(this, (MixinClass.__proto__ || (0, _getPrototypeOf2.default)(MixinClass)).apply(this, arguments));
      }

      return MixinClass;
    }(Base);

    var clonedMixin = Util.extend({}, mixin);
    // These React properties are defined as ES7 class static properties
    var staticProps = ["childContextTypes", "contextTypes", "defaultProps", "propTypes"];
    staticProps.forEach(function (staticProp) {
      MixinClass[staticProp] = clonedMixin[staticProp];
      delete clonedMixin[staticProp];
    });

    // Omit lifecycle functions because we are already storing them elsewhere
    Util.extend(MixinClass.prototype, Util.exclude(clonedMixin, lifecycleFunctions));

    return MixinClass;
  };
}

function setLifecycleMixinHandler(proto, lifecycleFn, mixins) {
  if (mixins == null || mixins.length === 0) {
    // No-ops so we need not check before calling super()
    proto[lifecycleFn] = noop;

    return;
  }

  proto[lifecycleFn] = function () {
    var _this2 = this;

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    mixins.forEach(function (mixin) {
      mixin.apply(_this2, args);
    });
  };
}

function addLifeCycleFunctions(proto, mixins) {
  var mixinLifecycleFnMap = {};
  mixins.forEach(function (mixin) {
    lifecycleFunctions.forEach(function (lifecycleFn) {
      if (mixin[lifecycleFn] == null) {
        return;
      }

      if (mixinLifecycleFnMap[lifecycleFn] == null) {
        mixinLifecycleFnMap[lifecycleFn] = [];
      }

      // Use push as we want to preserve order
      mixinLifecycleFnMap[lifecycleFn].push(mixin[lifecycleFn]);
    });
  });

  lifecycleFunctions.forEach(function (lifecycleFn) {
    setLifecycleMixinHandler(proto, lifecycleFn, mixinLifecycleFnMap[lifecycleFn]);
  });
}

var Util = {
  mixin: function mixin() {
    // Creates base class
    var Base = function (_React$Component) {
      (0, _inherits3.default)(Base, _React$Component);

      function Base() {
        (0, _classCallCheck3.default)(this, Base);
        return (0, _possibleConstructorReturn3.default)(this, (Base.__proto__ || (0, _getPrototypeOf2.default)(Base)).apply(this, arguments));
      }

      return Base;
    }(_react2.default.Component);

    Base.prototype.shouldComponentUpdate = trueNoop;

    for (var _len3 = arguments.length, mixins = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      mixins[_key3] = arguments[_key3];
    }

    addLifeCycleFunctions(Base.prototype, mixins);

    mixins.reverse();

    mixins.forEach(function (mixin) {
      /* eslint-disable no-class-assign */
      Base = es6ify(mixin)(Base);
      /* eslint-enable no-class-assign */
    });

    return Base;
  },


  // Superficial array check
  arrayDiff: function arrayDiff(a, b) {
    if (!a || !b) {
      return true;
    }

    return a.length !== b.length;
  },
  capitalize: function capitalize(string) {
    if (typeof string !== "string") {
      return null;
    }

    return string.charAt(0).toUpperCase() + string.slice(1, string.length);
  },


  // Add external custom functions
  clone: clone,
  exclude: exclude,
  extend: extend,
  find: find,
  isArray: isArray,

  // Add external underscore functions
  flatten: flatten,
  isEqual: isEqual,

  // Add external lodash functions
  isArguments: isArguments,
  isArrayLike: isArrayLike,
  isFunction: isFunction,
  isObjectLike: isObjectLike,
  noop: noop,
  pick: pick,
  sortBy: sortBy,
  trueNoop: trueNoop,
  values: values
};

module.exports = Util;