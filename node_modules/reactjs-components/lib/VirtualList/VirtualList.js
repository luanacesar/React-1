"use strict";

var _extends2 = require("babel-runtime/helpers/extends");

var _extends3 = _interopRequireDefault(_extends2);

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = require("react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _lodash = require("lodash.throttle");

var _lodash2 = _interopRequireDefault(_lodash);

var _DOMUtil = require("../Util/DOMUtil");

var _DOMUtil2 = _interopRequireDefault(_DOMUtil);

var _Util = require("../Util/Util");

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Largely based on the VirtualList component from
 * https://github.com/developerdizzle/react-virtual-list
 */

var mathMax = Math.max;
var mathMin = Math.min;
var mathFloor = Math.floor;
var mathCeil = Math.ceil;
var METHODS_TO_BIND = ["onScroll", "getBox", "getItems", "getItemsToRender", "getVirtualState", "visibleItems"];

var safeCall = function safeCall(f) {
  try {
    return f();
  } catch (e) {
    console.error(e);
  }
};

var VirtualList = function (_React$Component) {
  (0, _inherits3.default)(VirtualList, _React$Component);

  function VirtualList() {
    (0, _classCallCheck3.default)(this, VirtualList);

    var _this = (0, _possibleConstructorReturn3.default)(this, (VirtualList.__proto__ || (0, _getPrototypeOf2.default)(VirtualList)).apply(this, arguments));

    _this.state = _this.getVirtualState(_this.props);

    // Replace onScroll by throttling
    if (_this.props.scrollDelay > 0) {
      _this.onScroll = (0, _lodash2.default)(_this.onScroll, _this.props.scrollDelay,
      // Fire on both leading and trailing edge to minize flash of
      // un-rendered items
      { leading: true, trailing: true });
    }

    METHODS_TO_BIND.forEach(function (method) {
      _this[method] = _this[method].bind(_this);
    });

    _this.listRef = _react2.default.createRef();
    return _this;
  }

  (0, _createClass3.default)(VirtualList, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      // Make sure to trigger this scroll event and make necessary adjustments
      // before (useCapture = true) any other scroll event is handled
      this.props.container.addEventListener("scroll", this.onScroll, true);
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      if (this.props.container !== nextProps.container) {
        this.props.container.removeEventListener("scroll", this.onScroll, true);
        // Make sure to trigger this scroll event and make necessary adjustments
        // before (useCapture = true) any other scroll event is handled
        nextProps.container.addEventListener("scroll", this.onScroll, true);
      }

      var state = this.getVirtualState(nextProps);
      this.setState(state);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var props = this.props;
      props.container.removeEventListener("scroll", this.onScroll, true);
    }
  }, {
    key: "onScroll",
    value: function onScroll() {
      var state = this.getVirtualState(this.props);
      this.setState(state);
    }
  }, {
    key: "getBox",
    value: function getBox(view, list) {
      list.height = list.height || list.bottom - list.top;

      return {
        top: mathMax(0, mathMin(view.top - list.top)),
        bottom: mathMax(0, mathMin(list.height, view.bottom - list.top))
      };
    }
  }, {
    key: "getItems",
    value: function getItems(viewTop, viewHeight, listTop, itemHeight, itemCount, itemBuffer) {
      if (itemCount === 0 || itemHeight === 0) {
        return {
          firstItemIndex: 0,
          lastItemIndex: 0
        };
      }

      var listHeight = itemHeight * itemCount;

      var listBox = {
        top: listTop,
        height: listHeight,
        bottom: listTop + listHeight
      };

      var bufferHeight = itemBuffer * itemHeight;
      viewTop -= bufferHeight;
      viewHeight += bufferHeight * 2;

      var viewBox = {
        top: viewTop,
        bottom: viewTop + viewHeight
      };

      // List is below viewport
      if (viewBox.bottom < listBox.top) {
        return {
          firstItemIndex: 0,
          lastItemIndex: viewHeight / itemHeight + itemBuffer
        };
      }

      // List is above viewport
      if (viewBox.top > listBox.bottom) {
        return {
          firstItemIndex: 0,
          lastItemIndex: viewHeight / itemHeight + itemBuffer
        };
      }

      var listViewBox = this.getBox(viewBox, listBox);

      var firstItemIndex = mathMax(0, mathFloor(listViewBox.top / itemHeight));
      var lastItemIndex = mathCeil(listViewBox.bottom / itemHeight) - 1;

      var result = {
        firstItemIndex: firstItemIndex,
        lastItemIndex: lastItemIndex
      };

      return result;
    }
  }, {
    key: "getItemsToRender",
    value: function getItemsToRender(props, state) {
      return state.items.map(function (item, index) {
        return safeCall(function () {
          return props.renderItem(item,
          // Start from number of buffered items
          state.bufferStart / props.itemHeight + index);
        });
      });
    }
  }, {
    key: "getVirtualState",
    value: function getVirtualState(props) {
      // Default values
      var state = {
        bufferEnd: 0,
        bufferStart: 0,
        items: []
      };

      // Early return if nothing to render
      if (typeof props.container === "undefined" || props.items.length === 0 || props.itemHeight <= 0) {
        return state;
      }

      var items = props.items;
      var container = props.container;
      var viewHeight = _DOMUtil2.default.getViewportHeight();

      var viewTop = void 0;
      if (typeof container.scrollY !== "undefined") {
        viewTop = container.scrollY;
      } else {
        viewTop = _DOMUtil2.default.getScrollTop(container) || 0;
      }

      if (this.listRef && this.listRef.current) {
        var listBounding = _reactDom2.default.findDOMNode(this.listRef.current).getBoundingClientRect();

        var elementTop = listBounding.top + _DOMUtil2.default.getScrollTop(container) || 0;

        viewTop -= elementTop;
      }

      var renderStats = this.getItems(viewTop, viewHeight, 0, props.itemHeight, items.length, props.itemBuffer);

      state.items = items.slice(renderStats.firstItemIndex, renderStats.lastItemIndex + 1);

      state.bufferStart = renderStats.firstItemIndex * props.itemHeight;
      state.bufferEnd = (props.items.length - renderStats.lastItemIndex - 1) * props.itemHeight;

      return state;
    }

    // In case you need to get the currently visible items

  }, {
    key: "visibleItems",
    value: function visibleItems() {
      return this.state.items;
    }
  }, {
    key: "render",
    value: function render() {
      var state = this.state;
      var props = this.props;

      var topStyles = {
        height: state.bufferStart
      };

      if (!(state.bufferStart > 0)) {
        topStyles.display = "none";
      }

      var bottomStyles = {
        height: state.bufferEnd
      };

      if (!(state.bufferEnd > 0)) {
        bottomStyles.display = "none";
      }

      var htmlAttributes = _Util2.default.exclude(props, (0, _keys2.default)(VirtualList.propTypes));

      return _react2.default.createElement(
        props.tagName,
        (0, _extends3.default)({ ref: this.listRef }, htmlAttributes),
        safeCall(function () {
          return props.renderBufferItem(topStyles);
        }),
        this.getItemsToRender(props, state),
        safeCall(function () {
          return props.renderBufferItem(bottomStyles);
        })
      );
    }
  }]);
  return VirtualList;
}(_react2.default.Component);

VirtualList.defaultProps = {
  container: typeof window !== "undefined" ? window : undefined,
  itemBuffer: 0,
  scrollDelay: 0,
  tagName: "div"
};

VirtualList.propTypes = {
  // Array of items to render
  items: _propTypes2.default.array.isRequired,

  // The fixed height of a single item. Needs to be the same for all items
  // We suggest that you add a CSS rule to set the row height to the same value
  itemHeight: _propTypes2.default.number.isRequired,

  // This function should return the item view, the data model and the index
  // is passed to the function.
  // If you want to tweak performance, we suggest you memoize the results
  renderItem: _propTypes2.default.func.isRequired,

  // This function should return an item buffer view, the data model and the
  // index is passed to the function.
  renderBufferItem: _propTypes2.default.func.isRequired,

  // Optional item that the items should be rendered within. Defaults to window
  container: _propTypes2.default.object,

  // Optional Specify which tag the container should render
  tagName: _propTypes2.default.string,

  // Optional scroll delay to use in throttle function
  scrollDelay: _propTypes2.default.number,

  // Optional number of items to use as buffer, before and after viewport
  itemBuffer: _propTypes2.default.number
};

module.exports = VirtualList;